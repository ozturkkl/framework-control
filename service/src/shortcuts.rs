use std::env;
use std::fs;
use std::path::PathBuf;
use tracing::{info, warn, error};

#[cfg(target_os = "windows")]
pub fn get_shortcut_paths() -> Result<(PathBuf, PathBuf), String> {
    // Use ALLUSERSPROFILE for all-users Start Menu
    let start_menu_base = env::var("ALLUSERSPROFILE")
        .or_else(|_| env::var("PROGRAMDATA"))
        .map_err(|_| "Neither ALLUSERSPROFILE nor PROGRAMDATA environment variable found".to_string())?;
    let start_menu = PathBuf::from(start_menu_base).join(r"Microsoft\Windows\Start Menu\Programs\Framework Control.lnk");

    // Use PUBLIC for all-users Desktop
    let desktop_base = env::var("PUBLIC")
        .map_err(|_| "PUBLIC environment variable not found".to_string())?;
    let desktop = PathBuf::from(desktop_base).join(r"Desktop\Framework Control.lnk");

    Ok((start_menu, desktop))
}

#[cfg(target_os = "linux")]
pub fn get_shortcut_paths() -> Result<(PathBuf, PathBuf), String> {
    let user_home = crate::utils::fs::detect_user_home()
        .ok_or_else(|| "Could not determine user home directory".to_string())?;
    let applications = PathBuf::from(user_home)
        .join(".local/share/applications/framework-control.desktop");
    Ok((applications.clone(), applications))
}

pub fn shortcuts_exist() -> bool {
    match get_shortcut_paths() {
        Ok((first, second)) => {
            #[cfg(target_os = "windows")]
            {
                // Windows: check both Start Menu (.lnk or .url) and Desktop
                let exists_either = |p: &PathBuf| {
                    if p.exists() {
                        true
                    } else {
                        let url_variant = p.with_extension("url");
                        url_variant.exists()
                    }
                };
                exists_either(&first) && exists_either(&second)
            }
            #[cfg(target_os = "linux")]
            {
                // Linux: only check applications entry (second is same path)
                first.exists()
            }
        }
        Err(_) => false,
    }
}

#[cfg(all(target_os = "windows", feature = "embed-ui"))]
fn extract_icon() -> Result<PathBuf, String> {
    // Place icon where both SYSTEM and users can access: ProgramData\FrameworkControl\assets
    let program_data = env::var("PROGRAMDATA")
        .map_err(|_| "PROGRAMDATA environment variable not found".to_string())?;
    let assets_dir = PathBuf::from(program_data).join(r"FrameworkControl\assets");
    fs::create_dir_all(&assets_dir).map_err(|e| format!("Failed to create assets dir: {}", e))?;

    // ICO embedded at compile-time (generated by web build prior to service build)
    let ico_bytes: &[u8] = include_bytes!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../web/public/assets/generated/logo.ico"
    ));
    let ico_dest = assets_dir.join("framework-control.ico");
    fs::write(&ico_dest, ico_bytes).map_err(|e| format!("Failed to write ICO: {}", e))?;
    Ok(ico_dest)
}

#[cfg(all(target_os = "windows", not(feature = "embed-ui")))]
fn extract_icon() -> Result<PathBuf, String> {
    Err("Icon not embedded (embed-ui feature disabled)".to_string())
}

#[cfg(all(target_os = "linux", feature = "embed-ui"))]
fn extract_icon() -> Result<PathBuf, String> {
    let user_home = crate::utils::fs::detect_user_home()
        .ok_or_else(|| "Could not determine user home directory".to_string())?;

    // Write icon directly to final location in user's home
    let icon_dir = PathBuf::from(user_home).join(".local/share/framework-control/assets");
    fs::create_dir_all(&icon_dir).map_err(|e| format!("Failed to create icon dir: {}", e))?;

    let icon_path = icon_dir.join("framework-control.png");
    let png_bytes: &[u8] = include_bytes!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../web/public/assets/generated/logo.png"
    ));
    fs::write(&icon_path, png_bytes).map_err(|e| format!("Failed to write icon: {}", e))?;
    Ok(icon_path)
}

#[cfg(all(target_os = "linux", not(feature = "embed-ui")))]
fn extract_icon() -> Result<PathBuf, String> {
    Err("Icon not embedded (embed-ui feature disabled)".to_string())
}

#[cfg(target_os = "windows")]
pub async fn create_shortcuts(port: u16) -> Result<(), String> {
    let (start_menu_path, desktop_path) = get_shortcut_paths()?;
    let icon_path = extract_icon()?;

    info!(
        "shortcuts: creating at start_menu='{}', desktop='{}'",
        start_menu_path.display(),
        desktop_path.display()
    );

    let template = include_str!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/scripts/create_shortcuts.ps1"
    ));

    let ps_script = template
        .replace("{PORT}", &port.to_string())
        .replace("{ICON}", &icon_path.display().to_string())
        .replace("{START_MENU}", &start_menu_path.display().to_string())
        .replace("{DESKTOP}", &desktop_path.display().to_string());

    let output = tokio::process::Command::new("powershell")
        .arg("-NoProfile")
        .arg("-ExecutionPolicy")
        .arg("Bypass")
        .arg("-Command")
        .arg(&ps_script)
        .output()
        .await
        .map_err(|e| format!("Failed to execute PowerShell: {}", e))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(format!("PowerShell script failed: {}", stderr));
    }

    Ok(())
}

#[cfg(target_os = "linux")]
pub async fn create_shortcuts(port: u16) -> Result<(), String> {
    let user_home = crate::utils::fs::detect_user_home()
        .ok_or_else(|| "Could not determine user home directory".to_string())?;
    let icon_path = extract_icon()?;

    info!("shortcuts: creating desktop entry via script");

    let template = include_str!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/scripts/create_desktop_entry.sh"
    ));

    let bash_script = template
        .replace("{PORT}", &port.to_string())
        .replace("{USER_HOME}", &user_home);

    let output = tokio::process::Command::new("bash")
        .arg("-c")
        .arg(&bash_script)
        .output()
        .await
        .map_err(|e| format!("Failed to execute bash: {}", e))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(format!("Bash script failed: {}", stderr));
    }

    Ok(())
}

/// Check for installer marker file and create shortcuts if present
/// This is called once on service startup to handle the "create shortcuts on first run" option
pub async fn create_shortcuts_if_installer_requested() {
    // Look for marker file in the same directory as the executable
    let marker_path = match env::current_exe() {
        Ok(exe) => match exe.parent() {
            Some(dir) => dir.join("create_shortcuts.flag"),
            None => return,
        },
        Err(_) => return,
    };

    if !marker_path.exists() {
        return;
    }

    info!("Installer shortcut request detected, creating shortcuts...");

    // Get port from environment (required for service to run)
    let port = match env::var("FRAMEWORK_CONTROL_PORT")
        .ok()
        .or_else(|| option_env!("FRAMEWORK_CONTROL_PORT").map(String::from))
    {
        Some(p) => match p.parse::<u16>() {
            Ok(port) => port,
            Err(e) => {
                error!("Invalid FRAMEWORK_CONTROL_PORT: {}", e);
                return;
            }
        },
        None => {
            error!("FRAMEWORK_CONTROL_PORT not set, cannot create shortcuts");
            return;
        }
    };

    // Create shortcuts
    match create_shortcuts(port).await {
        Ok(_) => {
            info!("Shortcuts created successfully");
            // Remove marker file so we don't create shortcuts again
            if let Err(e) = fs::remove_file(&marker_path) {
                warn!("Failed to remove shortcut marker file: {}", e);
            }
        }
        Err(e) => error!("Failed to create shortcuts: {}", e),
    }
}
